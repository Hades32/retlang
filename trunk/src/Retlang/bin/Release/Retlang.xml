<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Retlang</name>
    </assembly>
    <members>
        <member name="T:Retlang.IReply`1">
            <summary>
            Response to Request.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Retlang.IReply`1.Message">
            <summary>
            The body of the reply
            </summary>
        </member>
        <member name="P:Retlang.IReply`1.Header">
            <summary>
            Reply Header.
            </summary>
        </member>
        <member name="T:Retlang.IRequestReply`1">
            <summary>
            Blocking interface for a request.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.IRequestReply`1.Receive(System.Int32)">
            <summary>
            Returns immediately if reply has already been received. Blocks waiting for reply or timeout.
            </summary>
            <param name="waitTimeoutInMs"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.XmlTransferEnvelope">
            <summary>
            Uses xml serialization for defensive cloning.
            </summary>
        </member>
        <member name="T:Retlang.ITransferEnvelope">
            <summary>
            Packages a message for transfer between contexts.
            </summary>
        </member>
        <member name="M:Retlang.ITransferEnvelope.ResolveMessage">
            <summary>
            Called when the message is delivered to an individual subscriber.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.ITransferEnvelope.CanCastTo``1">
            <summary>
            Determines whether the message can be cast to the generic type.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Retlang.ITransferEnvelope.MessageType">
            <summary>
            The type of the message contained in the envelope.
            </summary>
        </member>
        <member name="P:Retlang.ITransferEnvelope.Header">
            <summary>
            The topic and reply topic of the message.
            </summary>
        </member>
        <member name="M:Retlang.XmlTransferEnvelope.#ctor(System.Object,System.Object,System.Object)">
            <summary>
            Creates a new instance and copies the message using xml serialization.
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyTo"></param>
        </member>
        <member name="M:Retlang.XmlTransferEnvelope.CanCastTo``1">
            <summary>
            <see cref="M:Retlang.ITransferEnvelope.CanCastTo``1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Retlang.XmlTransferEnvelope.ResolveMessage">
            <summary>
            Parses the xml bytes into a new object.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Retlang.XmlTransferEnvelope.MessageType">
            <summary>
            <see cref="P:Retlang.ITransferEnvelope.MessageType"/>
            </summary>
        </member>
        <member name="P:Retlang.XmlTransferEnvelope.Header">
            <summary>
            <see cref="P:Retlang.ITransferEnvelope.Header"/>
            </summary>
        </member>
        <member name="T:Retlang.ITopicMatcher">
            <summary>
            Matches a topic.
            </summary>
        </member>
        <member name="M:Retlang.ITopicMatcher.Matches(System.Object)">
            <summary>
            Return true on match.
            </summary>
            <param name="topic"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.IUnsubscriber">
            <summary>
            Unsubscribe controller.
            </summary>
        </member>
        <member name="M:Retlang.IUnsubscriber.Unsubscribe">
            <summary>
            Unsubscribe.
            </summary>
        </member>
        <member name="T:Retlang.ProcessContext">
            <summary>
            ProcessBus backed by a dedicated thread.
            </summary>
        </member>
        <member name="T:Retlang.ProcessBus">
            <summary>
            Base class for thread and pool backed process bus instances.
            </summary>
        </member>
        <member name="T:Retlang.IProcessBus">
            <summary>
            Provides methods for publishing and subscribing to events. Events will be delivered sequentially. 
            </summary>
        </member>
        <member name="T:Retlang.IObjectPublisher">
            <summary>
            Methods for publishing messages.
            </summary>
        </member>
        <member name="M:Retlang.IObjectPublisher.Publish(System.Object,System.Object,System.Object)">
            <summary>
            Publish a message with a reply Topic
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyToTopic"></param>
        </member>
        <member name="M:Retlang.IObjectPublisher.Publish(System.Object,System.Object)">
            <summary>
            Publish message on the given topic.
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
        </member>
        <member name="T:Retlang.ICommandQueue">
            <summary>
            Queue for command objects.
            </summary>
        </member>
        <member name="M:Retlang.ICommandQueue.Enqueue(Retlang.Command)">
            <summary>
            Append command to end of queue.
            </summary>
            <param name="command"></param>
        </member>
        <member name="T:Retlang.ICommandTimer">
            <summary>
            Methods for schedule events that will be executed in the future.
            </summary>
        </member>
        <member name="M:Retlang.ICommandTimer.Schedule(Retlang.Command,System.Int64)">
            <summary>
            Schedules an event to be executes once.
            </summary>
            <param name="command"></param>
            <param name="firstIntervalInMs"></param>
            <returns>a controller to cancel the event.</returns>
        </member>
        <member name="M:Retlang.ICommandTimer.ScheduleOnInterval(Retlang.Command,System.Int64,System.Int64)">
            <summary>
            Schedule an event on a recurring interval.
            </summary>
            <param name="command"></param>
            <param name="firstIntervalInMs"></param>
            <param name="regularIntervalInMs"></param>
            <returns>controller to cancel timer.</returns>
        </member>
        <member name="M:Retlang.IProcessBus.Publish(Retlang.ITransferEnvelope)">
            <summary>
            Publish the message.
            </summary>
            <param name="toPublish"></param>
        </member>
        <member name="M:Retlang.IProcessBus.Post(System.Object,System.Object,System.Object)">
            <summary>
            Posts a message to this context only. The message is not broadcast.
            Returns true if a subscriber is found.
            </summary>
        </member>
        <member name="M:Retlang.IProcessBus.SubscribeToKeyedBatch``2(Retlang.ITopicMatcher,Retlang.ResolveKey{``0,``1},Retlang.On{System.Collections.Generic.IDictionary{``0,Retlang.IMessageEnvelope{``1}}},System.Int32)">
            <summary>
            A batch subscription that drops duplicates based upon the ResolveKey delegate provided.
            </summary>
        </member>
        <member name="M:Retlang.IProcessBus.SubscribeToBatch``1(Retlang.ITopicMatcher,Retlang.On{System.Collections.Generic.IList{Retlang.IMessageEnvelope{``0}}},System.Int32)">
            <summary>
            A batch subscription that delivers a list of events to the subscriber.
            </summary>
        </member>
        <member name="M:Retlang.IProcessBus.SubscribeToLast``1(Retlang.ITopicMatcher,Retlang.OnMessage{``0},System.Int32)">
            <summary>
            Batch subscription that only delivers the last event to the target delegate.
            </summary>
        </member>
        <member name="M:Retlang.IProcessBus.Subscribe``1(Retlang.ITopicMatcher,Retlang.OnMessage{``0})">
            <summary>
            Subscribe for events on based upon the matcher and generic type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessBus.SendRequest``1(Retlang.ITransferEnvelope)">
            <summary>
            Send a request using the provided wrapped message
            </summary>
            <typeparam name="T"></typeparam>
            <param name="env"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessBus.SendRequest``1(System.Object,System.Object)">
            <summary>
            Send request message.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessBus.SendAsyncRequest``1(System.Object,System.Object,Retlang.OnMessage{``0},Retlang.Command,System.Int64)">
            <summary>
            Send async request. The timeout command will be invoked if a reply is not returned within the timeout period.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="onReply"></param>
            <param name="onTimeout"></param>
            <param name="requestTimeout"></param>
        </member>
        <member name="M:Retlang.IProcessBus.CreateUniqueTopic">
            <summary>
            Returns a new unique topic. The topic is unique only within the process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessBus.Start">
            <summary>
            Start receiving events.
            </summary>
        </member>
        <member name="M:Retlang.IProcessBus.Stop">
            <summary>
            Stop receiving events.
            </summary>
        </member>
        <member name="E:Retlang.IProcessBus.QueueFullEvent">
            <summary>
            Callback from any and all publishing threads. Not Thread Safe.
            Will only happen if the max size of the queue and the max wait times are set.
            </summary>
        </member>
        <member name="T:Retlang.ISubscriber">
            <summary>
            Subscriber for message bus events.
            </summary>
        </member>
        <member name="M:Retlang.ISubscriber.Receive(Retlang.ITransferEnvelope,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="envelope"></param>
            <param name="consumed">set to true ONLY if the subscriber consumes the event. Do NOT set to false since events are invoked using a multicast event</param>
        </member>
        <member name="M:Retlang.ProcessBus.#ctor(Retlang.IMessageBus,Retlang.IProcessQueue,Retlang.ITransferEnvelopeFactory)">
            <summary>
            construct new instance.
            </summary>
            <param name="messageBus"></param>
            <param name="runner"></param>
            <param name="factory"></param>
        </member>
        <member name="M:Retlang.ProcessBus.Start">
            <summary>
            Start receiving events.
            </summary>
        </member>
        <member name="M:Retlang.ProcessBus.Stop">
            <summary>
            Stop receiving events.
            </summary>
        </member>
        <member name="M:Retlang.ProcessBus.Schedule(Retlang.Command,System.Int64)">
            <summary>
            <see cref="M:Retlang.ICommandTimer.Schedule(Retlang.Command,System.Int64)"/>
            </summary>
            <param name="command"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.ScheduleOnInterval(Retlang.Command,System.Int64,System.Int64)">
            <summary>
            <see cref="M:Retlang.ICommandTimer.ScheduleOnInterval(Retlang.Command,System.Int64,System.Int64)"/>
            </summary>
            <param name="command"></param>
            <param name="firstIntervalInMs"></param>
            <param name="regularIntervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.Enqueue(Retlang.Command)">
            <summary>
            <see cref="M:Retlang.ICommandQueue.Enqueue(Retlang.Command)"/>
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Retlang.ProcessBus.Publish(System.Object,System.Object,System.Object)">
            <summary>
            <see cref="M:Retlang.IObjectPublisher.Publish(System.Object,System.Object,System.Object)"/>
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyToTopic"></param>
        </member>
        <member name="M:Retlang.ProcessBus.Publish(Retlang.ITransferEnvelope)">
            <summary>
            Publish the wrapped message.
            </summary>
            <param name="toPublish"></param>
        </member>
        <member name="M:Retlang.ProcessBus.Publish(System.Object,System.Object)">
            <summary>
            <see cref="M:Retlang.IObjectPublisher.Publish(System.Object,System.Object)"/>
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.ProcessBus.Post(System.Object,System.Object,System.Object)">
            <summary>
            Posts the message directly to the process bus. The message is not broadcast.
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyToTopic"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.SubscribeToKeyedBatch``2(Retlang.ITopicMatcher,Retlang.ResolveKey{``0,``1},Retlang.On{System.Collections.Generic.IDictionary{``0,Retlang.IMessageEnvelope{``1}}},System.Int32)">
            <summary>
            Subscribe to batched events. The key resolver allows duplicates to be dropped if events arrive faster
            than the bus can consume the events.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="topic"></param>
            <param name="keyResolver"></param>
            <param name="target"></param>
            <param name="minBatchIntervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.SubscribeToBatch``1(Retlang.ITopicMatcher,Retlang.On{System.Collections.Generic.IList{Retlang.IMessageEnvelope{``0}}},System.Int32)">
            <summary>
            A batched subscription. An interval can be specified for batching.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="minBatchIntervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.SubscribeToLast``1(Retlang.ITopicMatcher,Retlang.OnMessage{``0},System.Int32)">
            <summary>
            Subscribes to the last event. Stale events are dropped in favor of newer events. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="minBatchIntervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.Subscribe``1(Retlang.ITopicMatcher,Retlang.OnMessage{``0})">
            <summary>
            Subscribe to all events matching the generic type and topic matcher.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.CreateUniqueTopic">
            <summary>
            Creates a unique topic for this process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.SendRequest``1(Retlang.ITransferEnvelope)">
            <summary>
            <see cref="M:Retlang.IProcessBus.SendRequest``1(Retlang.ITransferEnvelope)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="env"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.SendAsyncRequest``1(System.Object,System.Object,Retlang.OnMessage{``0},Retlang.Command,System.Int64)">
            <summary>
            <see cref="M:Retlang.IProcessBus.SendAsyncRequest``1(System.Object,System.Object,Retlang.OnMessage{``0},Retlang.Command,System.Int64)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="onReply"></param>
            <param name="onTimeout"></param>
            <param name="requestTimeout"></param>
        </member>
        <member name="M:Retlang.ProcessBus.SendRequest``1(System.Object,System.Object)">
            <summary>
            <see cref="M:Retlang.IProcessBus.SendRequest``1(System.Object,System.Object)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessBus.Receive(Retlang.ITransferEnvelope,System.Boolean@)">
            <summary>
            Receives event.
            </summary>
            <param name="envelope"></param>
            <param name="consumed"></param>
        </member>
        <member name="E:Retlang.ProcessBus.QueueFullEvent">
            <summary>
            Fired when queue is full.
            </summary>
        </member>
        <member name="T:Retlang.IProcessContext">
            <summary>
            A process bus backed by a thread.
            <seealso cref="T:Retlang.IProcessBus"/>
            </summary>
        </member>
        <member name="M:Retlang.IProcessContext.Join">
            <summary>
            Wait for underlying thread to complete.
            </summary>
        </member>
        <member name="M:Retlang.IProcessContext.Join(System.Int32)">
            <summary>
            Wait for underlying thread to complete or for the timeout to expire.
            </summary>
            <param name="milliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContext.#ctor(Retlang.IMessageBus,Retlang.IProcessThread,Retlang.ITransferEnvelopeFactory)">
            <summary>
            Construct new intance.
            </summary>
            <param name="messageBus"></param>
            <param name="runner"></param>
            <param name="factory"></param>
        </member>
        <member name="M:Retlang.ProcessContext.Join">
            <summary>
            Wait for backing thread to finish.
            </summary>
        </member>
        <member name="M:Retlang.ProcessContext.Join(System.Int32)">
            <summary>
            Wait with timeout for backing thread to finish.
            </summary>
            <param name="milliseconds"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.ObjectTransferEnvelope">
            <summary>
            Transfer objects between contexts without serialization.
            </summary>
        </member>
        <member name="M:Retlang.ObjectTransferEnvelope.#ctor(System.Object,Retlang.IMessageHeader)">
            <summary>
            </summary>
            <param name="obj">data to publish</param>
            <param name="header">header</param>
        </member>
        <member name="M:Retlang.ObjectTransferEnvelope.CanCastTo``1">
            <summary>
            <see cref="M:Retlang.ITransferEnvelope.CanCastTo``1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Retlang.ObjectTransferEnvelope.ResolveMessage">
            <summary>
            <see cref="M:Retlang.ITransferEnvelope.ResolveMessage"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Retlang.ObjectTransferEnvelope.MessageType">
            <summary>
            <see cref="P:Retlang.ITransferEnvelope.MessageType"/>
            </summary>
        </member>
        <member name="P:Retlang.ObjectTransferEnvelope.Header">
            <summary>
            <see cref="P:Retlang.ITransferEnvelope.Header"/>
            </summary>
        </member>
        <member name="T:Retlang.BinaryTransferEnvelope">
            <summary>
            Transfer Envelope that uses object serialization to create defensive copies when passing objects across thread.
            </summary>
        </member>
        <member name="M:Retlang.BinaryTransferEnvelope.#ctor(System.Object,System.Object,System.Object)">
            <summary>
            Construct a new instance. Message is serialized to bytes during construction.
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyTo"></param>
        </member>
        <member name="T:Retlang.IMessageHeader">
            <summary>
            The topic and reply topic for the message.
            </summary>
        </member>
        <member name="P:Retlang.IMessageHeader.Topic">
            <summary>
            The published topic
            </summary>
        </member>
        <member name="P:Retlang.IMessageHeader.ReplyTo">
            <summary>
            optional reply topic
            </summary>
        </member>
        <member name="T:Retlang.MessageHeader">
            <summary>
            Default MesageHeader implementation.
            </summary>
        </member>
        <member name="M:Retlang.MessageHeader.#ctor(System.Object,System.Object)">
            <summary>
            Construct Header.
            </summary>
            <param name="topic"></param>
            <param name="replyTo"></param>
        </member>
        <member name="M:Retlang.MessageHeader.GetHashCode">
            <summary>
            <see cref="M:System.Object.GetHashCode"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.MessageHeader.Equals(System.Object)">
            <summary>
            Compares topic and replyTo properties.
            <see cref="M:System.Object.Equals(System.Object)"/>
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Retlang.MessageHeader.Topic">
            <summary>
            <see cref="P:Retlang.IMessageHeader.Topic"/>
            </summary>
        </member>
        <member name="P:Retlang.MessageHeader.ReplyTo">
            <summary>
            <see cref="P:Retlang.IMessageHeader.ReplyTo"/>
            </summary>
        </member>
        <member name="T:Retlang.ITransferEnvelopeFactory">
            <summary>
            Wraps a message for transfer across threads.
            </summary>
        </member>
        <member name="M:Retlang.ITransferEnvelopeFactory.Create(System.Object,System.Object,System.Object)">
            <summary>
            Creates an envelope.
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyTo"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.ObjectTransferEnvelopeFactory">
            <summary>
            Create a simple wrapper for the object. Does not serialize or copy the object.  
            </summary>
        </member>
        <member name="M:Retlang.ObjectTransferEnvelopeFactory.Create(System.Object,System.Object,System.Object)">
            <summary>
            <see cref="M:Retlang.ITransferEnvelopeFactory.Create(System.Object,System.Object,System.Object)"/>
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyTo"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.BinaryTransferEnvelopeFactory">
            <summary>
            Serializes the object and creates a copy for each thread when the message is delivered.
            </summary>
        </member>
        <member name="M:Retlang.BinaryTransferEnvelopeFactory.Create(System.Object,System.Object,System.Object)">
            <summary>
            <see cref="M:Retlang.ITransferEnvelopeFactory.Create(System.Object,System.Object,System.Object)"/>
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyTo"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.XmlTransferEnvelopeFactory">
            <summary>
            Uses the XmlSerializer to create a defensive clone.
            </summary>
        </member>
        <member name="M:Retlang.XmlTransferEnvelopeFactory.Create(System.Object,System.Object,System.Object)">
            <summary>
            <see cref="M:Retlang.ITransferEnvelopeFactory.Create(System.Object,System.Object,System.Object)"/>
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyTo"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.TopicRegex">
            <summary>
            Matches topic based upon a regular expression. Topic must be a string.
            </summary>
        </member>
        <member name="M:Retlang.TopicRegex.#ctor(System.Text.RegularExpressions.Regex)">
            <summary>
            Create a new instance with the provided Regex.
            </summary>
            <param name="reg"></param>
        </member>
        <member name="M:Retlang.TopicRegex.Matches(System.Object)">
            <summary>
            Matches if the topic is a string and it matches the Regex.
            </summary>
            <param name="topic"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ChannelLastSubscriber`1.#ctor(System.Action{`0},Retlang.ICommandTimer,System.Int32)">
            <summary>
            New instance.
            </summary>
            <param name="target"></param>
            <param name="context"></param>
            <param name="flushIntervalInMs"></param>
        </member>
        <member name="M:Retlang.ChannelLastSubscriber`1.OnReceive(`0)">
            <summary>
            Receives message from producer thread.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.ChannelLastSubscriber`1.Flush">
            <summary>
            Flushes on IProcessTimer thread.
            </summary>
        </member>
        <member name="T:Retlang.QueueFullException">
            <summary>
            Thrown when a queue is full.
            </summary>
        </member>
        <member name="M:Retlang.QueueFullException.#ctor(System.Int32)">
            <summary>
            Construct the execution with the depth of the queue.
            </summary>
            <param name="depth"></param>
        </member>
        <member name="M:Retlang.QueueFullException.#ctor(System.String)">
            <summary>
            Construct with a custom message.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="P:Retlang.QueueFullException.Depth">
            <summary>
            Depth of queue.
            </summary>
        </member>
        <member name="T:Retlang.CommandExecutor">
            <summary>
            Default command executor.
            </summary>
        </member>
        <member name="T:Retlang.ICommandExecutor">
            <summary>
            Executes the pending events on for the process bus.
            </summary>
        </member>
        <member name="M:Retlang.ICommandExecutor.ExecuteAll(Retlang.Command[])">
            <summary>
            Execute all pending events for the process bus.
            </summary>
            <param name="toExecute"></param>
        </member>
        <member name="M:Retlang.CommandExecutor.ExecuteAll(Retlang.Command[])">
            <summary>
            <see cref="M:Retlang.ICommandExecutor.ExecuteAll(Retlang.Command[])"/>
            </summary>
            <param name="toExecute"></param>
        </member>
        <member name="P:Retlang.CommandExecutor.IsEnabled">
            <summary>
            When disabled, commands will be ignored by executor. The executor is typically disabled at shutdown
            to prevent any pending commands from being executed. 
            </summary>
        </member>
        <member name="T:Retlang.LastSubscriber`1">
            <summary>
            Subscribes to last event from queue. Old events are discarded.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.LastSubscriber`1.#ctor(Retlang.OnMessage{`0},Retlang.ICommandTimer,System.Int32)">
            <summary>
            New instance.
            </summary>
            <param name="target"></param>
            <param name="context"></param>
            <param name="flushIntervalInMs"></param>
        </member>
        <member name="M:Retlang.LastSubscriber`1.ReceiveMessage(Retlang.IMessageHeader,`0)">
            <summary>
            Receives message from delivery thread.
            </summary>
            <param name="header"></param>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.LastSubscriber`1.Flush">
            <summary>
            Flushes on IProcessBus thread.
            </summary>
        </member>
        <member name="T:Retlang.OnReceive">
            <summary>
            Delegate for message delivery.
            </summary>
            <param name="envelope"></param>
            <param name="received"></param>
        </member>
        <member name="T:Retlang.ISubscriberRegistry">
            <summary>
            Registry for message subscribers.
            </summary>
        </member>
        <member name="M:Retlang.ISubscriberRegistry.Subscribe(Retlang.ISubscriber)">
            <summary>
            Subscribe to all events.
            </summary>
            <param name="subscriber"></param>
        </member>
        <member name="M:Retlang.ISubscriberRegistry.Unsubscribe(Retlang.ISubscriber)">
            <summary>
            Unsubscribe.
            </summary>
            <param name="subscriber"></param>
        </member>
        <member name="T:Retlang.IPendingCommandRegistry">
            <summary>
            Stores and removes pending commands.
            </summary>
        </member>
        <member name="M:Retlang.IPendingCommandRegistry.Remove(Retlang.ITimerControl)">
            <summary>
            Remove timer
            </summary>
            <param name="timer"></param>
        </member>
        <member name="M:Retlang.IPendingCommandRegistry.EnqueueTask(Retlang.Command)">
            <summary>
            Queue event to target queue.
            </summary>
            <param name="command"></param>
        </member>
        <member name="T:Retlang.ITimerControl">
            <summary>
            Controller to cancel event timer.
            </summary>
        </member>
        <member name="M:Retlang.ITimerControl.Cancel">
            <summary>
            Cancels scheduled timer.
            </summary>
        </member>
        <member name="T:Retlang.IMessageEnvelope`1">
            <summary>
            Wraps the message body and header.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Retlang.IMessageEnvelope`1.Header">
            <summary>
            Topic and reply to
            </summary>
        </member>
        <member name="P:Retlang.IMessageEnvelope`1.Message">
            <summary>
            Body
            </summary>
        </member>
        <member name="T:Retlang.MessageEnvelope`1">
            <summary>
            Default implementation for IMessageEnvelope
            <see cref="T:Retlang.IMessageEnvelope`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.MessageEnvelope`1.#ctor(Retlang.IMessageHeader,`0)">
            <summary>
            new instance.
            </summary>
            <param name="header"></param>
            <param name="msg"></param>
        </member>
        <member name="P:Retlang.MessageEnvelope`1.Header">
            <summary>
            <see cref="P:Retlang.IMessageEnvelope`1.Header"/>
            </summary>
        </member>
        <member name="P:Retlang.MessageEnvelope`1.Message">
            <summary>
            <see cref="P:Retlang.IMessageEnvelope`1.Message"/>
            </summary>
        </member>
        <member name="M:Retlang.ChannelKeyedBatchSubscriber`2.OnReceive(`1)">
            <summary>
            received on delivery thread
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.ChannelKeyedBatchSubscriber`2.Flush">
            <summary>
            Flushed from process thread
            </summary>
        </member>
        <member name="T:Retlang.TopicSubscriber`1">
            <summary>
            Default message bus subscriber implementation.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.TopicSubscriber`1.#ctor(Retlang.ITopicMatcher,Retlang.OnMessage{`0})">
            <summary>
            Create new instance.
            </summary>
            <param name="topic"></param>
            <param name="onMessage"></param>
        </member>
        <member name="M:Retlang.TopicSubscriber`1.Receive(Retlang.ITransferEnvelope,System.Boolean@)">
            <summary>
            Event received on delivery thread.
            </summary>
            <param name="envelope"></param>
            <param name="consumed"></param>
        </member>
        <member name="P:Retlang.TopicSubscriber`1.Topic">
            <summary>
            Subscription topic
            </summary>
        </member>
        <member name="P:Retlang.TopicSubscriber`1.MessageType">
            <summary>
            Expected Type.
            </summary>
        </member>
        <member name="T:Retlang.OnQueueFull">
            <summary>
            Fired when a process queue is full.
            </summary>
            <param name="exception"></param>
            <param name="header"></param>
            <param name="msg"></param>
        </member>
        <member name="T:Retlang.TopicEquals">
            <summary>
            Matches topic using the object equals methods.
            <seealso cref="M:System.Object.Equals(System.Object)"/>
            </summary>
        </member>
        <member name="M:Retlang.TopicEquals.#ctor(System.Object)">
            <summary>
            Construct new matcher.
            </summary>
            <param name="toMatch"></param>
        </member>
        <member name="M:Retlang.TopicEquals.GetHashCode">
            <summary>
            Returns the hashcode of the matching object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.TopicEquals.Equals(System.Object)">
            <summary>
            <see cref="M:System.Object.Equals(System.Object)"/>
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.TopicEquals.Matches(System.Object)">
            <summary>
            <see cref="M:Retlang.ITopicMatcher.Matches(System.Object)"/>
            </summary>
            <param name="topic"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.TopicEquals.ToString">
            <summary>
            <see cref="M:System.Object.ToString"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Retlang.IThreadController">
            <summary>
            Controls thread lifecycle.
            </summary>
        </member>
        <member name="M:Retlang.IThreadController.Start">
            <summary>
            Starts thread execution.
            </summary>
        </member>
        <member name="M:Retlang.IThreadController.Stop">
            <summary>
            Stops thread
            </summary>
        </member>
        <member name="M:Retlang.IThreadController.Join">
            <summary>
            Waits for thread to finish.
            </summary>
        </member>
        <member name="T:Retlang.PoolQueue">
            <summary>
            Process Queue that uses a thread pool for execution.
            </summary>
        </member>
        <member name="T:Retlang.IProcessQueue">
            <summary>
            Queues pending events for the process.
            </summary>
        </member>
        <member name="M:Retlang.IProcessQueue.Start">
            <summary>
            Start consuming events.
            </summary>
        </member>
        <member name="M:Retlang.IProcessQueue.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="M:Retlang.PoolQueue.#ctor(Retlang.IThreadPool,Retlang.ICommandExecutor)">
            <summary>
            Construct new instance.
            </summary>
            <param name="pool"></param>
            <param name="executor"></param>
        </member>
        <member name="M:Retlang.PoolQueue.#ctor">
            <summary>
            Create a pool queue with the default thread pool and command executor.
            </summary>
        </member>
        <member name="M:Retlang.PoolQueue.Enqueue(Retlang.Command)">
            <summary>
            <see cref="M:Retlang.ICommandQueue.Enqueue(Retlang.Command)"/>
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Retlang.PoolQueue.Schedule(Retlang.Command,System.Int64)">
            <summary>
            <see cref="M:Retlang.ICommandTimer.Schedule(Retlang.Command,System.Int64)"/>
            </summary>
            <param name="command"></param>
            <param name="firstIntervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.PoolQueue.ScheduleOnInterval(Retlang.Command,System.Int64,System.Int64)">
            <summary>
            <see cref="M:Retlang.ICommandTimer.ScheduleOnInterval(Retlang.Command,System.Int64,System.Int64)"/>
            </summary>
            <param name="command"></param>
            <param name="firstIntervalInMs"></param>
            <param name="regularIntervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.PoolQueue.Start">
            <summary>
            Start consuming events.
            </summary>
        </member>
        <member name="M:Retlang.PoolQueue.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="T:Retlang.ResolveKey`2">
            <summary>
            Resolves a message to a key.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="header"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.KeyedBatchSubscriber`2">
            <summary>
            Batches messages and drops duplicates based upon the resolved key.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="M:Retlang.KeyedBatchSubscriber`2.#ctor(Retlang.ResolveKey{`0,`1},Retlang.On{System.Collections.Generic.IDictionary{`0,Retlang.IMessageEnvelope{`1}}},Retlang.ICommandTimer,System.Int32)">
            <summary>
            Constructs new instance.
            </summary>
            <param name="keyResolver"></param>
            <param name="target"></param>
            <param name="context"></param>
            <param name="flushIntervalInMs"></param>
        </member>
        <member name="M:Retlang.KeyedBatchSubscriber`2.ReceiveMessage(Retlang.IMessageHeader,`1)">
            <summary>
            received on delivery thread
            </summary>
            <param name="header"></param>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.KeyedBatchSubscriber`2.Flush">
            <summary>
            Flushed from process thread
            </summary>
        </member>
        <member name="T:Retlang.IsMatch`1">
            <summary>
            Return true if the topic matches.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.TopicSelector`1">
            <summary>
            Matches the topic based upon the generic type and provided matcher.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.TopicSelector`1.#ctor(Retlang.IsMatch{`0})">
            <summary>
            Construct selector with provided matcher.
            </summary>
            <param name="matcher"></param>
        </member>
        <member name="M:Retlang.TopicSelector`1.Matches(System.Object)">
            <summary>
            Returns true if the topic type matches the generic type
            and the matcher returns true.
            </summary>
            <param name="topic"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.IProcessThreadFactory">
            <summary>
            Factory for creating backing threads.
            </summary>
        </member>
        <member name="M:Retlang.IProcessThreadFactory.CreateProcessThread(Retlang.ICommandExecutor)">
            <summary>
            Create ProcessThread with ICommandExecutor
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessThreadFactory.CreateMessageBusThread(Retlang.ICommandExecutor)">
            <summary>
            Create thread for message bus
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessThreadFactory.CreateProcessThread(Retlang.ICommandExecutor,System.String)">
            <summary>
            Create named process thread.
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessThreadFactory.CreateMessageBusThread(Retlang.ICommandExecutor,System.String)">
            <summary>
            Create named message bus thread.
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.ProcessThreadFactory">
            <summary>
            Default implementation for IProcessThreadFactory
            </summary>
        </member>
        <member name="M:Retlang.ProcessThreadFactory.CreateProcessThread(Retlang.ICommandExecutor)">
            <summary>
            <see cref="M:Retlang.IProcessThreadFactory.CreateProcessThread(Retlang.ICommandExecutor)"/>
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessThreadFactory.CreateMessageBusThread(Retlang.ICommandExecutor)">
            <summary>
            <see cref="M:Retlang.IProcessThreadFactory.CreateMessageBusThread(Retlang.ICommandExecutor)"/>
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessThreadFactory.CreateProcessThread(Retlang.ICommandExecutor,System.String)">
            <summary>
            <see cref="M:Retlang.IProcessThreadFactory.CreateProcessThread(Retlang.ICommandExecutor,System.String)"/>
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessThreadFactory.CreateMessageBusThread(Retlang.ICommandExecutor,System.String)">
            <summary>
            <see cref="M:Retlang.IProcessThreadFactory.CreateMessageBusThread(Retlang.ICommandExecutor,System.String)"/>
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="P:Retlang.ProcessThreadFactory.MaxQueueDepth">
            <summary>
            Maximum depth for queue.
            </summary>
        </member>
        <member name="P:Retlang.ProcessThreadFactory.MaxEnqueueWaitTime">
            <summary>
            Max time to wait for queue to clear.
            </summary>
        </member>
        <member name="T:Retlang.IThreadPool">
            <summary>
            A thread pool for executing asynchronous events.
            </summary>
        </member>
        <member name="M:Retlang.IThreadPool.Queue(System.Threading.WaitCallback)">
            <summary>
            Queue event for execution.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="T:Retlang.DefaultThreadPool">
            <summary>
            Default implementation that uses the .NET thread pool.
            </summary>
        </member>
        <member name="M:Retlang.DefaultThreadPool.Queue(System.Threading.WaitCallback)">
            <summary>
            Queue event.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="T:Retlang.SynchronousCommandQueue">
            <summary>
            A synchronous queue typically used for testing.
            </summary>
        </member>
        <member name="T:Retlang.ICommandRunner">
            <summary>
            A runable queue implementation.
            </summary>
        </member>
        <member name="M:Retlang.ICommandRunner.Run">
            <summary>
            Consume events.
            </summary>
        </member>
        <member name="M:Retlang.ICommandRunner.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="M:Retlang.SynchronousCommandQueue.Enqueue(Retlang.Command)">
            <summary>
            <see cref="M:Retlang.ICommandQueue.Enqueue(Retlang.Command)"/>
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Retlang.SynchronousCommandQueue.Run">
            <summary>
            Start Consuming events.
            </summary>
        </member>
        <member name="M:Retlang.SynchronousCommandQueue.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="T:Retlang.IProcessContextFactory">
            <summary>
            Creates process bus objects using the backing thread pool or dedicated threads. 
            <see cref="T:Retlang.IProcessBus"/>
            </summary>
        </member>
        <member name="M:Retlang.IProcessContextFactory.CreateAndStart">
            <summary>
            Creates a new thread backed context. Starts the thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.Create">
            <summary>
            Creates a thread backed context. Does not start the thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.CreateAndStart(Retlang.ICommandExecutor)">
            <summary>
            Creates and starts a thread backed context using the provided executor.
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.Create(Retlang.ICommandExecutor)">
            <summary>
            Creates a thread backed context with the provided executor.
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.CreateAndStart(System.String)">
            <summary>
            Creates and starts a named thread backed context.
            </summary>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.Create(System.String)">
            <summary>
            Creates a context with a named thread.
            </summary>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.CreateAndStart(Retlang.ICommandExecutor,System.String)">
            <summary>
            Creates and starts thread backed context with the provided thread name and executor
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.Create(Retlang.ICommandExecutor,System.String)">
            <summary>
            Creates thread backed context with the provided thread name and executor.
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.CreatePooledAndStart(Retlang.ICommandExecutor)">
            <summary>
            Creates and start process bus using the provided executor and the default thread pool.
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.CreatePooledAndStart">
            <summary>
            Create and start a process bus that using the thread pool.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.CreatePooled(Retlang.ICommandExecutor)">
            <summary>
            Create pool backed proces bus with the provided command executor.
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IProcessContextFactory.CreatePooled">
            <summary>
            Create a pool backed process bus.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Retlang.IProcessContextFactory.MessageBus">
            <summary>
            The underlying message bus used for message delivery.
            </summary>
        </member>
        <member name="T:Retlang.ProcessContextFactory">
            <summary>
            Default IProcessContextFactory implementation.
            </summary>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Start">
            <summary>
            Initializes message bus and starts delivery thread.
            </summary>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Init">
            <summary>
            Initializes the message bus.
            </summary>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Stop">
            <summary>
            Stops message bus thread.
            </summary>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Join">
            <summary>
            Wait for message bus thread.
            </summary>
        </member>
        <member name="M:Retlang.ProcessContextFactory.CreateAndStart">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.CreateAndStart"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Create">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.Create"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.CreateAndStart(Retlang.ICommandExecutor)">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.CreateAndStart(Retlang.ICommandExecutor)"/>
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Create(Retlang.ICommandExecutor)">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.Create(Retlang.ICommandExecutor)"/>
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.CreateAndStart(System.String)">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.CreateAndStart(System.String)"/>
            </summary>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Create(System.String)">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.Create(System.String)"/>
            </summary>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.CreateAndStart(Retlang.ICommandExecutor,System.String)">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.CreateAndStart(Retlang.ICommandExecutor,System.String)"/>
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Create(Retlang.ICommandExecutor,System.String)">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.Create(Retlang.ICommandExecutor,System.String)"/>
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.CreatePooled">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.CreatePooled"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.CreatePooled(Retlang.ICommandExecutor)">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.CreatePooled(Retlang.ICommandExecutor)"/>
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.CreatePooledAndStart">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.CreatePooledAndStart"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.CreatePooledAndStart(Retlang.ICommandExecutor)">
            <summary>
            <see cref="M:Retlang.IProcessContextFactory.CreatePooledAndStart(Retlang.ICommandExecutor)"/>
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Publish(System.Object,System.Object,System.Object)">
            <summary>
            Publishes message to the underlying message bus.
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
            <param name="replyToTopic"></param>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Publish(System.Object,System.Object)">
            <summary>
            Publishes message to the underlying message bus.
            </summary>
            <param name="topic"></param>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.ProcessContextFactory.Dispose">
            <summary>
            Stop message bus thread.
            </summary>
        </member>
        <member name="P:Retlang.ProcessContextFactory.MessageBusCommandExecutor">
            <summary>
            Command executor for message bus.
            </summary>
        </member>
        <member name="P:Retlang.ProcessContextFactory.ThreadPool">
            <summary>
            Backing thread pool for pool backed process bus instances.
            </summary>
        </member>
        <member name="P:Retlang.ProcessContextFactory.MessageBus">
            <summary>
            Backing message bus.
            </summary>
        </member>
        <member name="P:Retlang.ProcessContextFactory.TransferEnvelopeFactory">
            <summary>
            Transfer envelope factory used by the process contexts.
            </summary>
        </member>
        <member name="P:Retlang.ProcessContextFactory.ThreadFactory">
            <summary>
            Thread factory for message bus and process context instances.
            </summary>
        </member>
        <member name="T:Retlang.On`1">
            <summary>
            Message delivery delegate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="msg"></param>
        </member>
        <member name="T:Retlang.OnMessage`1">
            <summary>
            Retlang message delivery delegate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="header"></param>
            <param name="msg"></param>
        </member>
        <member name="T:Retlang.IMessageBus">
            <summary>
            Delivers published events to registered subscribers.
            </summary>
        </member>
        <member name="M:Retlang.IMessageBus.Publish(Retlang.ITransferEnvelope)">
            <summary>
            Publish message to all subscribers.
            </summary>
            <param name="envelope"></param>
        </member>
        <member name="E:Retlang.IMessageBus.UnhandledMessageEvent">
            <summary>
            Fired if event is not consumed by any subscriber.
            </summary>
        </member>
        <member name="T:Retlang.MessageBus">
            <summary>
            Default message bus implementation.
            </summary>
        </member>
        <member name="M:Retlang.MessageBus.#ctor(Retlang.ICommandQueue)">
            <summary>
            Constructs a message bus with the provided backing queue.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:Retlang.MessageBus.Enqueue(Retlang.Command)">
            <summary>
            Append command to queue.
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Retlang.MessageBus.Publish(Retlang.ITransferEnvelope)">
            <summary>
            Deliver message to any and all interested subscribers.
            </summary>
            <param name="envelope"></param>
        </member>
        <member name="M:Retlang.MessageBus.Subscribe(Retlang.ISubscriber)">
            <summary>
            Subscribe to events.
            </summary>
            <param name="subscriber"></param>
        </member>
        <member name="M:Retlang.MessageBus.Unsubscribe(Retlang.ISubscriber)">
            <summary>
            Unsubscribe
            </summary>
            <param name="sub"></param>
        </member>
        <member name="E:Retlang.MessageBus.UnhandledMessageEvent">
            <summary>
            <see cref="E:Retlang.IMessageBus.UnhandledMessageEvent"/>
            </summary>
        </member>
        <member name="P:Retlang.MessageBus.AsyncPublish">
            <summary>
            Toggles whether events are delivered directly to subscribers by publishing thread or the events are queued
            and delivered by the message bus thread.
            </summary>
        </member>
        <member name="T:Retlang.IProcessThread">
            <summary>
            A process queue backed by a thread.
            </summary>
        </member>
        <member name="M:Retlang.IProcessThread.Join">
            <summary>
            Wait for the thread to complete.
            </summary>
        </member>
        <member name="P:Retlang.IProcessThread.Thread">
            <summary>
            The backing thead.
            </summary>
        </member>
        <member name="T:Retlang.ProcessThread">
            <summary>
            Default implementation for IProcessThread.
            <see cref="T:Retlang.IProcessThread"/>
            </summary>
        </member>
        <member name="M:Retlang.ProcessThread.#ctor(Retlang.ICommandRunner)">
            <summary>
            Creates a new thread with the backing runner.
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Retlang.ProcessThread.#ctor">
            <summary>
            Create a process thread with a default queue.
            </summary>
        </member>
        <member name="M:Retlang.ProcessThread.#ctor(Retlang.ICommandRunner,System.String)">
            <summary>
            Creates a new thread.
            </summary>
            <param name="queue">The queue</param>
            <param name="threadName">custom thread name</param>
        </member>
        <member name="M:Retlang.ProcessThread.#ctor(Retlang.ICommandRunner,System.String,System.Boolean)">
            <summary>
            Create process thread.
            </summary>
            <param name="queue"></param>
            <param name="threadName"></param>
            <param name="isBackground"></param>
        </member>
        <member name="M:Retlang.ProcessThread.Enqueue(Retlang.Command)">
            <summary>
            <see cref="M:Retlang.ICommandQueue.Enqueue(Retlang.Command)"/>
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Retlang.ProcessThread.Schedule(Retlang.Command,System.Int64)">
            <summary>
            <see cref="M:Retlang.ICommandTimer.Schedule(Retlang.Command,System.Int64)"/>
            </summary>
            <param name="command"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ProcessThread.ScheduleOnInterval(Retlang.Command,System.Int64,System.Int64)">
            <summary>
            <see cref="M:Retlang.ICommandTimer.ScheduleOnInterval(Retlang.Command,System.Int64,System.Int64)"/>
            </summary>
            <param name="command"></param>
            <param name="firstInMs"></param>
            <param name="intervalInMs"></param>
        </member>
        <member name="M:Retlang.ProcessThread.Stop">
            <summary>
            <see cref="M:Retlang.IProcessQueue.Stop"/>
            </summary>
        </member>
        <member name="M:Retlang.ProcessThread.Start">
            <summary>
            <see cref="M:Retlang.IProcessQueue.Start"/>
            </summary>
        </member>
        <member name="M:Retlang.ProcessThread.Join">
            <summary>
            <see cref="M:Retlang.IProcessThread.Join"/>
            </summary>
        </member>
        <member name="P:Retlang.ProcessThread.Thread">
            <summary>
            <see cref="P:Retlang.IProcessThread.Thread"/>
            </summary>
        </member>
        <member name="T:Retlang.IPendingEvent">
            <summary>
            A scheduled event.
            </summary>
        </member>
        <member name="M:Retlang.IPendingEvent.Execute(System.Int64)">
            <summary>
            Execute this event and optionally schedule another execution.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Retlang.IPendingEvent.Expiration">
            <summary>
            Time of expiration for this event
            </summary>
        </member>
        <member name="T:Retlang.TimerThread">
            <summary>
            A Thread dedicated to event scheduling.
            </summary>
        </member>
        <member name="T:Retlang.RequestReplyChannel`2">
            <summary>
            Channel for synchronous and asynchronous requests.
            </summary>
            <typeparam name="R"></typeparam>
            <typeparam name="M"></typeparam>
        </member>
        <member name="M:Retlang.RequestReplyChannel`2.Subscribe(Retlang.IProcessBus,System.Action{Retlang.IChannelRequest{`0,`1}})">
            <summary>
            Subscribe to requests.
            </summary>
            <param name="responder"></param>
            <param name="onRequest"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.RequestReplyChannel`2.SendRequest(`0)">
            <summary>
            Send request to any and all subscribers.
            </summary>
            <param name="p"></param>
            <returns>null if no subscribers registered for request.</returns>
        </member>
        <member name="T:Retlang.IChannelRequest`2">
            <summary>
            A request object that can be used to send 1 or many responses to the initial request.
            </summary>
            <typeparam name="R"></typeparam>
            <typeparam name="M"></typeparam>
        </member>
        <member name="M:Retlang.IChannelRequest`2.SendReply(`1)">
            <summary>
            Send one or more responses.
            </summary>
            <param name="replyMsg"></param>
            <returns></returns>
        </member>
        <member name="P:Retlang.IChannelRequest`2.Request">
            <summary>
            Request Message
            </summary>
        </member>
        <member name="T:Retlang.IChannelReply`1">
            <summary>
            Used to receive one or more replies.
            </summary>
            <typeparam name="M"></typeparam>
        </member>
        <member name="M:Retlang.IChannelReply`1.Receive(System.Int32,`0@)">
            <summary>
            Receive a single response. Can be called repeatedly for multiple replies.
            </summary>
            <param name="timeout"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.ChannelRequest`2.Dispose">
            <summary>
            Stop receiving replies.
            </summary>
        </member>
        <member name="T:Retlang.Command">
            <summary>
            Command delegate.
            </summary>
        </member>
        <member name="T:Retlang.OnException">
            <summary>
            An exception delegate for a command failure.
            </summary>
            <param name="command"></param>
            <param name="failure"></param>
        </member>
        <member name="T:Retlang.CommandQueue">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:Retlang.CommandQueue.Enqueue(Retlang.Command)">
            <summary>
            <see cref="M:Retlang.ICommandQueue.Enqueue(Retlang.Command)"/>
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Retlang.CommandQueue.DequeueAll">
            <summary>
            Remove all commands.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.CommandQueue.ExecuteNextBatch">
            <summary>
            Remove all commands and execute.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.CommandQueue.Run">
            <summary>
            Execute commands until stopped.
            </summary>
        </member>
        <member name="M:Retlang.CommandQueue.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="P:Retlang.CommandQueue.Executor">
            <summary>
            Executor for events.
            </summary>
        </member>
        <member name="P:Retlang.CommandQueue.MaxDepth">
            <summary>
            Max number of events to be queued.
            </summary>
        </member>
        <member name="P:Retlang.CommandQueue.MaxEnqueueWaitTime">
            <summary>
            Max time to wait for space in the queue.
            </summary>
        </member>
        <member name="T:Retlang.IChannelSubscriber`1">
            <summary>
            Channel subscription methods.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.IChannelSubscriber`1.Subscribe(Retlang.ICommandQueue,System.Action{`0})">
            <summary>
             Subscribe to messages on this channel. The provided action will be invoked via a command on the provided queue.
            </summary>
            <param name="queue">the target context to receive the message</param>
            <param name="receive"></param>
            <returns>Unsubscriber object</returns>
        </member>
        <member name="M:Retlang.IChannelSubscriber`1.ClearSubscribers">
            <summary>
            Removes all subscribers.
            </summary>
        </member>
        <member name="M:Retlang.IChannelSubscriber`1.SubscribeToBatch(Retlang.ICommandTimer,System.Action{System.Collections.Generic.IList{`0}},System.Int32)">
            <summary>
            Subscribes to events on the channel in batch form. The events will be batched if the consumer is unable to process the events 
            faster than the arrival rate.
            </summary>
            <param name="queue">The target context to execute the action</param>
            <param name="receive"></param>
            <param name="intervalInMs">Time in Ms to batch events. If 0 events will be delivered as fast as consumer can process</param>
            <returns></returns>
        </member>
        <member name="M:Retlang.IChannelSubscriber`1.SubscribeToKeyedBatch``1(Retlang.ICommandTimer,System.Converter{`0,``0},System.Action{System.Collections.Generic.IDictionary{``0,`0}},System.Int32)">
            <summary>
             Batches events based upon keyed values allowing for duplicates to be dropped. 
            </summary>
            <param name="queue"></param>
            <param name="keyResolver"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <typeparam name="K"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Retlang.IChannelPublisher`1">
            <summary>
            Channel publishing interface.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.IChannelPublisher`1.Publish(`0)">
            <summary>
            Publish a message to all subscribers. Returns true if any subscribers are registered.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.IChannel`1">
            <summary>
            A channel provides a conduit for messages. It provides methods for publishing and subscribing to messages. 
            The class is thread safe.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Retlang.Channel`1">
            <summary>
             Default Channel Implementation. Methods are thread safe.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channel`1.Subscribe(Retlang.ICommandQueue,System.Action{`0})">
            <summary>
            <see cref="M:Retlang.IChannelSubscriber`1.Subscribe(Retlang.ICommandQueue,System.Action{`0})"/>
            </summary>
            <param name="queue"></param>
            <param name="receive"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channel`1.Publish(`0)">
            <summary>
            <see cref="M:Retlang.IChannelPublisher`1.Publish(`0)"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channel`1.ClearSubscribers">
            <summary>
            Remove all subscribers.
            </summary>
        </member>
        <member name="M:Retlang.Channel`1.SubscribeToBatch(Retlang.ICommandTimer,System.Action{System.Collections.Generic.IList{`0}},System.Int32)">
            <summary>
            <see cref="M:Retlang.IChannelSubscriber`1.SubscribeToBatch(Retlang.ICommandTimer,System.Action{System.Collections.Generic.IList{`0}},System.Int32)"/>
            </summary>
            <param name="queue"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channel`1.SubscribeToKeyedBatch``1(Retlang.ICommandTimer,System.Converter{`0,``0},System.Action{System.Collections.Generic.IDictionary{``0,`0}},System.Int32)">
            <summary>
            <see cref="M:Retlang.IChannelSubscriber`1.SubscribeToKeyedBatch``1(Retlang.ICommandTimer,System.Converter{`0,``0},System.Action{System.Collections.Generic.IDictionary{``0,`0}},System.Int32)"/>
            </summary>
            <typeparam name="K"></typeparam>
            <param name="queue"></param>
            <param name="keyResolver"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channel`1.SubscribeOnProducerThreads(System.Action{`0})">
            <summary>
            Subscribes an action to be executed for every event posted to the channel. Action should be thread safe. 
            Action may be invoked on multiple threads.
            </summary>
            <param name="subscriber"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channel`1.SubscribeToLast(Retlang.ICommandTimer,System.Action{`0},System.Int32)">
            <summary>
            Subscription that delivers the latest message to the consuming thread.  If a newer message arrives before the consuming thread
            has a chance to process the message, the pending message is replaced by the newer message. The old message is discarded.
            </summary>
            <param name="queue"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
    </members>
</doc>
