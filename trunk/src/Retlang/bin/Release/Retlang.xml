<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Retlang</name>
    </assembly>
    <members>
        <member name="T:Retlang.Core.TimerThread">
            <summary>
            A Thread dedicated to event scheduling.
            </summary>
        </member>
        <member name="T:Retlang.Core.ActionTimer">
            <summary>
             Enqueues actions on to executor after schedule elapses.  
            </summary>
        </member>
        <member name="T:Retlang.Core.IPendingActionRegistry">
            <summary>
            Stores and removes pending actions.
            </summary>
        </member>
        <member name="M:Retlang.Core.IPendingActionRegistry.Remove(Retlang.Core.ITimerControl)">
            <summary>
            Remove timer
            </summary>
            <param name="timer"></param>
        </member>
        <member name="M:Retlang.Core.IPendingActionRegistry.EnqueueTask(System.Action)">
            <summary>
            Queue event to target queue.
            </summary>
            <param name="action"></param>
        </member>
        <member name="T:Retlang.Core.IScheduler">
            <summary>
            Methods for schedule events that will be executed in the future.
            </summary>
        </member>
        <member name="M:Retlang.Core.IScheduler.Schedule(System.Action,System.Int64)">
            <summary>
            Schedules an event to be executes once.
            </summary>
            <param name="action"></param>
            <param name="timeTilEnqueueInMs"></param>
            <returns>a controller to cancel the event.</returns>
        </member>
        <member name="M:Retlang.Core.IScheduler.ScheduleOnInterval(System.Action,System.Int64,System.Int64)">
            <summary>
            Schedule an event on a recurring interval.
            </summary>
            <param name="action"></param>
            <param name="firstInMs"></param>
            <param name="regularInMs"></param>
            <returns>controller to cancel timer.</returns>
        </member>
        <member name="M:Retlang.Core.ActionTimer.#ctor(Retlang.Core.IDisposingExecutor)">
            <summary>
             Constructs new instance.
            </summary>
        </member>
        <member name="M:Retlang.Core.ActionTimer.Schedule(System.Action,System.Int64)">
            <summary>
             Enqueues action on to executor after timer elapses.  
            </summary>
        </member>
        <member name="M:Retlang.Core.ActionTimer.ScheduleOnInterval(System.Action,System.Int64,System.Int64)">
            <summary>
             Enqueues actions on to executor after schedule elapses.  
            </summary>
        </member>
        <member name="M:Retlang.Core.ActionTimer.Remove(Retlang.Core.ITimerControl)">
            <summary>
             Removes a pending scheduled action.
            </summary>
            <param name="toRemove"></param>
        </member>
        <member name="M:Retlang.Core.ActionTimer.EnqueueTask(System.Action)">
            <summary>
             Enqueues actions on to executor immediately.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Retlang.Core.ActionTimer.Dispose">
            <summary>
             Cancels all pending actions
            </summary>
        </member>
        <member name="T:Retlang.Channels.IQueueChannel`1">
            <summary>
            Creates a queue that will deliver a message to a single consumer. Load balancing can be achieved by creating 
            multiple subscribers to the queue.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.IQueueChannel`1.Subscribe(Retlang.Core.IDisposingExecutor,System.Action{`0})">
            <summary>
            Subscribe to the executor.
            </summary>
            <param name="executor"></param>
            <param name="onMessage"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.IQueueChannel`1.Publish(`0)">
            <summary>
            Pushes a message into the queue. Message will be processed by first available consumer.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Retlang.Core.IUnsubscriber">
            <summary>
            Unsubscribe controller.
            </summary>
        </member>
        <member name="T:Retlang.Fibers.IFiber">
            <summary>
            Queues pending events for the fiber.
            </summary>
        </member>
        <member name="T:Retlang.Core.IDisposingExecutor">
            <summary>
            Queues actions. Disposable objects can be added and removed. All dispose methods registered with the executor 
            will be invoked with the executor is disposed. This allows all subscriptions to be disposed when a fiber 
            is disposed.
            </summary>
        </member>
        <member name="M:Retlang.Core.IDisposingExecutor.EnqueueAll(System.Action[])">
            <summary>
            Append actions to end of queue.
            </summary>
            <param name="actions"></param>
        </member>
        <member name="M:Retlang.Core.IDisposingExecutor.Enqueue(System.Action)">
            <summary>
            Enqueue a single action.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Retlang.Core.IDisposingExecutor.Add(System.IDisposable)">
            <summary>
            Register disposable.
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:Retlang.Core.IDisposingExecutor.Remove(System.IDisposable)">
            <summary>
            Remove Disposable.
            </summary>
            <param name="victim"></param>
            <returns></returns>
        </member>
        <member name="P:Retlang.Core.IDisposingExecutor.DisposableCount">
            <summary>
            Number of registered disposables.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.IFiber.Start">
            <summary>
            Start consuming events.
            </summary>
        </member>
        <member name="T:Retlang.Channels.BatchSubscriber`1">
            <summary>
            Batches events for the consuming thread.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Retlang.Channels.BaseSubscription`1">
            <summary>
            Base implementation for subscription
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Retlang.Channels.ISubscribable`1">
            <summary>
            Callback method and parameters for a channel subscription
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Retlang.Channels.IProducerThreadSubscriber`1">
            <summary>
            Event Subscriber that receives events on producer thread.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.IProducerThreadSubscriber`1.ReceiveOnProducerThread(`0)">
            <summary>
            Method called from producer threads
            </summary>
            <param name="msg"></param>
        </member>
        <member name="P:Retlang.Channels.ISubscribable`1.FilterOnProducerThread">
            <summary>
            Filter called from producer threads. Should be thread safe as it may be called from
            multiple threads.
            </summary>
        </member>
        <member name="M:Retlang.Channels.BaseSubscription`1.ReceiveOnProducerThread(`0)">
            <summary>
            <see cref="M:Retlang.Channels.IProducerThreadSubscriber`1.ReceiveOnProducerThread(`0)"/>
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.Channels.BaseSubscription`1.OnMessageOnProducerThread(`0)">
            <summary>
            Called after message has been filtered.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="P:Retlang.Channels.BaseSubscription`1.FilterOnProducerThread">
            <summary>
            <see cref="P:Retlang.Channels.ISubscribable`1.FilterOnProducerThread"/>
            </summary>
        </member>
        <member name="M:Retlang.Channels.BatchSubscriber`1.#ctor(Retlang.Core.IScheduler,System.Action{System.Collections.Generic.IList{`0}},System.Int32)">
            <summary>
            Construct new instance.
            </summary>
            <param name="queue"></param>
            <param name="receive"></param>
            <param name="interval"></param>
        </member>
        <member name="M:Retlang.Channels.BatchSubscriber`1.OnMessageOnProducerThread(`0)">
            <summary>
            Receives message and batches as needed.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Retlang.Fibers.FormFiber">
            <summary>
             Allows interaction with Windows Forms.  Transparently moves actions onto the Form's thread.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.#ctor(System.ComponentModel.ISynchronizeInvoke,Retlang.Core.IBatchAndSingleExecutor)">
            <summary>
            Creates an instance.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.EnqueueAll(System.Action[])">
            <summary>
            <see cref="M:Retlang.Core.IDisposingExecutor.EnqueueAll(System.Action[])"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.Enqueue(System.Action)">
            <summary>
            <see cref="M:Retlang.Core.IDisposingExecutor.Enqueue(System.Action)"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.Add(System.IDisposable)">
            <summary>
            <see cref="M:Retlang.Core.IDisposingExecutor.Add(System.IDisposable)"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.Remove(System.IDisposable)">
            <summary>
            <see cref="M:Retlang.Core.IDisposingExecutor.Remove(System.IDisposable)"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.Schedule(System.Action,System.Int64)">
            <summary>
            <see cref="M:Retlang.Core.IScheduler.Schedule(System.Action,System.Int64)"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.ScheduleOnInterval(System.Action,System.Int64,System.Int64)">
            <summary>
            <see cref="M:Retlang.Core.IScheduler.ScheduleOnInterval(System.Action,System.Int64,System.Int64)"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.Start">
            <summary>
            <see cref="M:Retlang.Fibers.IFiber.Start"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.Stop">
            <summary>
            Stops the fiber.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.FormFiber.Dispose">
            <summary>
            <see cref="M:System.IDisposable.Dispose"/>
            </summary>
        </member>
        <member name="P:Retlang.Fibers.FormFiber.DisposableCount">
            <summary>
            <see cref="P:Retlang.Core.IDisposingExecutor.DisposableCount"/>
            </summary>
        </member>
        <member name="T:Retlang.Core.ITimerControl">
            <summary>
            Controller to cancel event timer.
            </summary>
        </member>
        <member name="M:Retlang.Core.ITimerControl.Cancel">
            <summary>
            Cancels scheduled timer.
            </summary>
        </member>
        <member name="T:Retlang.Core.QueueFullException">
            <summary>
            Thrown when a queue is full.
            </summary>
        </member>
        <member name="M:Retlang.Core.QueueFullException.#ctor(System.Int32)">
            <summary>
            Construct the execution with the depth of the queue.
            </summary>
            <param name="depth"></param>
        </member>
        <member name="M:Retlang.Core.QueueFullException.#ctor(System.String)">
            <summary>
            Construct with a custom message.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="P:Retlang.Core.QueueFullException.Depth">
            <summary>
            Depth of queue.
            </summary>
        </member>
        <member name="T:Retlang.Core.IBatchExecutor">
            <summary>
            Executes pending action(s).
            </summary>
        </member>
        <member name="M:Retlang.Core.IBatchExecutor.ExecuteAll(System.Action[])">
            <summary>
            Execute all pending actions.
            </summary>
            <param name="toExecute"></param>
        </member>
        <member name="T:Retlang.Fibers.IThreadFiber">
            <summary>
            Fiber implementation backed by a dedicated thread.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.IThreadFiber.Join">
            <summary>
            Willl Wait for Thread to cease execution before continuing.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.IThreadFiber.Thread">
            <summary>
            The backing thread for the Fiber.
            </summary>
        </member>
        <member name="T:Retlang.Core.BatchExecutor">
            <summary>
            Default Action executor.
            </summary>
        </member>
        <member name="M:Retlang.Core.BatchExecutor.ExecuteAll(System.Action[])">
            <summary>
            <see cref="M:Retlang.Core.IBatchExecutor.ExecuteAll(System.Action[])"/>
            </summary>
        </member>
        <member name="P:Retlang.Core.BatchExecutor.IsEnabled">
            <summary>
            When disabled, actions will be ignored by executor. The executor is typically disabled at shutdown
            to prevent any pending actions from being executed. 
            </summary>
        </member>
        <member name="T:Retlang.Fibers.PoolFiber">
            <summary>
            Fiber that uses a thread pool for execution.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.#ctor(Retlang.Core.IThreadPool,Retlang.Core.IBatchExecutor)">
            <summary>
            Construct new instance.
            </summary>
            <param name="pool"></param>
            <param name="executor"></param>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.#ctor(Retlang.Core.IBatchExecutor)">
            <summary>
            Create a pool fiber with the default thread pool.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.#ctor">
            <summary>
            Create a pool fiber with the default thread pool and batch executor.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.EnqueueAll(System.Action[])">
            <summary>
            <see cref="M:Retlang.Core.IDisposingExecutor.EnqueueAll(System.Action[])"/>
            </summary>
            <param name="actions"></param>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.Enqueue(System.Action)">
            <summary>
            Queue action.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.Add(System.IDisposable)">
            <summary>
            Register Disposable.
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.Remove(System.IDisposable)">
            <summary>
            Remove Disposable.
            </summary>
            <param name="victim"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.Schedule(System.Action,System.Int64)">
            <summary>
            <see cref="M:Retlang.Core.IScheduler.Schedule(System.Action,System.Int64)"/>
            </summary>
            <param name="action"></param>
            <param name="timeTilEnqueueInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.ScheduleOnInterval(System.Action,System.Int64,System.Int64)">
            <summary>
            <see cref="M:Retlang.Core.IScheduler.ScheduleOnInterval(System.Action,System.Int64,System.Int64)"/>
            </summary>
            <param name="action"></param>
            <param name="firstInMs"></param>
            <param name="regularInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.Start">
            <summary>
            Start consuming events.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.PoolFiber.Dispose">
            <summary>
            Stops the fiber.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.PoolFiber.DisposableCount">
            <summary>
            Number of currently registered disposables.
            </summary>
        </member>
        <member name="T:Retlang.Channels.KeyedBatchSubscriber`2">
            <summary>
            Channel subscription that drops duplicates based upon a key.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.KeyedBatchSubscriber`2.#ctor(System.Converter{`1,`0},System.Action{System.Collections.Generic.IDictionary{`0,`1}},Retlang.Core.IScheduler,System.Int32)">
            <summary>
            Construct new instance.
            </summary>
            <param name="keyResolver"></param>
            <param name="target"></param>
            <param name="context"></param>
            <param name="flushIntervalInMs"></param>
        </member>
        <member name="M:Retlang.Channels.KeyedBatchSubscriber`2.OnMessageOnProducerThread(`1)">
            <summary>
            received on delivery thread
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.Channels.KeyedBatchSubscriber`2.Flush">
            <summary>
            Flushed from fiber
            </summary>
        </member>
        <member name="T:Retlang.Channels.IRequest`2">
            <summary>
            A request object that can be used to send 1 or many responses to the initial request.
            </summary>
            <typeparam name="R"></typeparam>
            <typeparam name="M"></typeparam>
        </member>
        <member name="M:Retlang.Channels.IRequest`2.SendReply(`1)">
            <summary>
            Send one or more responses.
            </summary>
            <param name="replyMsg"></param>
            <returns></returns>
        </member>
        <member name="P:Retlang.Channels.IRequest`2.Request">
            <summary>
            Request Message
            </summary>
        </member>
        <member name="T:Retlang.Core.IActionExecutor">
            <summary>
            A runable queue implementation.
            </summary>
        </member>
        <member name="M:Retlang.Core.IActionExecutor.Run">
            <summary>
            Consume events.
            </summary>
        </member>
        <member name="M:Retlang.Core.IActionExecutor.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="T:Retlang.Channels.LastSubscriber`1">
            <summary>
            Subscribes to last event received on the channel. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.LastSubscriber`1.#ctor(System.Action{`0},Retlang.Core.IScheduler,System.Int32)">
            <summary>
            New instance.
            </summary>
            <param name="target"></param>
            <param name="context"></param>
            <param name="flushIntervalInMs"></param>
        </member>
        <member name="M:Retlang.Channels.LastSubscriber`1.OnMessageOnProducerThread(`0)">
            <summary>
            Receives message from producer thread.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Retlang.Channels.LastSubscriber`1.Flush">
            <summary>
            Flushes on IFiber thread.
            </summary>
        </member>
        <member name="T:Retlang.Channels.IPublisher`1">
            <summary>
            Channel publishing interface.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.IPublisher`1.Publish(`0)">
            <summary>
            Publish a message to all subscribers. Returns true if any subscribers are registered.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.Channels.IChannel`1">
            <summary>
            A channel provides a conduit for messages. It provides methods for publishing and subscribing to messages. 
            The class is thread safe.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Retlang.Channels.ISubscriber`1">
            <summary>
            Channel subscription methods.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.ISubscriber`1.Subscribe(Retlang.Core.IDisposingExecutor,System.Action{`0})">
            <summary>
             Subscribe to messages on this channel. The provided action will be invoked via a Action on the provided executor.
            </summary>
            <param name="executor">the target context to receive the message</param>
            <param name="receive"></param>
            <returns>Unsubscriber object</returns>
        </member>
        <member name="M:Retlang.Channels.ISubscriber`1.ClearSubscribers">
            <summary>
            Removes all subscribers.
            </summary>
        </member>
        <member name="M:Retlang.Channels.ISubscriber`1.SubscribeToBatch(Retlang.Core.IScheduler,System.Action{System.Collections.Generic.IList{`0}},System.Int32)">
            <summary>
            Subscribes to events on the channel in batch form. The events will be batched if the consumer is unable to process the events 
            faster than the arrival rate.
            </summary>
            <param name="scheduler">The target context to execute the action</param>
            <param name="receive"></param>
            <param name="intervalInMs">Time in Ms to batch events. If 0 events will be delivered as fast as consumer can process</param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.ISubscriber`1.SubscribeToKeyedBatch``1(Retlang.Core.IScheduler,System.Converter{`0,``0},System.Action{System.Collections.Generic.IDictionary{``0,`0}},System.Int32)">
            <summary>
             Batches events based upon keyed values allowing for duplicates to be dropped. 
            </summary>
            <param name="scheduler"></param>
            <param name="keyResolver"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <typeparam name="K"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.ISubscriber`1.SubscribeToLast(Retlang.Core.IScheduler,System.Action{`0},System.Int32)">
            <summary>
            Subscription that delivers the latest message to the consuming thread.  If a newer message arrives before the consuming thread
            has a chance to process the message, the pending message is replaced by the newer message. The old message is discarded.
            </summary>
            <param name="scheduler"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.ISubscriber`1.SubscribeOnProducerThreads(System.Action{`0})">
            <summary>
            Subscribes to messages on producer threads. Action will be invoked on producer thread. Action must
            be thread safe.
            </summary>
            <param name="subscriber"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.ISubscriber`1.SubscribeOnProducerThreads(Retlang.Channels.IProducerThreadSubscriber{`0})">
            <summary>
            Subscribes to events on producer threads. Subscriber could be called from multiple threads.
            </summary>
            <param name="subscriber"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.Channels.IReply`1">
            <summary>
            Used to receive one or more replies.
            </summary>
            <typeparam name="M"></typeparam>
        </member>
        <member name="M:Retlang.Channels.IReply`1.Receive(System.Int32,`0@)">
            <summary>
            Receive a single response. Can be called repeatedly for multiple replies.
            </summary>
            <param name="timeout"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.ChannelRequest`2.Dispose">
            <summary>
            Stop receiving replies.
            </summary>
        </member>
        <member name="T:Retlang.Fibers.ThreadFiber">
            <summary>
            Default implementation for IThreadFiber.
            <see cref="T:Retlang.Fibers.IFiber"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.#ctor(Retlang.Core.IActionExecutor)">
            <summary>
            Creates a new thread with the backing executor.
            </summary>
            <param name="executor"></param>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.#ctor">
            <summary>
            Create a fiber thread with a default action executor.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.#ctor(Retlang.Core.IActionExecutor,System.String)">
            <summary>
            Creates a new thread.
            </summary>
            <param name="executor">The queue</param>
            <param name="threadName">custom thread name</param>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.#ctor(Retlang.Core.IActionExecutor,System.String,System.Boolean,System.Threading.ThreadPriority)">
            <summary>
            Create fiber thread.
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <param name="isBackground"></param>
            <param name="priority"></param>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.EnqueueAll(System.Action[])">
            <summary>
            <see cref="M:Retlang.Core.IDisposingExecutor.EnqueueAll(System.Action[])"/>
            </summary>
            <param name="actions"></param>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.Enqueue(System.Action)">
            <summary>
            Queue action.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.Add(System.IDisposable)">
            <summary>
            Add Disposable to be invoked when Fiber is disposed.
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.Remove(System.IDisposable)">
            <summary>
            Remove disposable.
            </summary>
            <param name="victim"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.Schedule(System.Action,System.Int64)">
            <summary>
            <see cref="M:Retlang.Core.IScheduler.Schedule(System.Action,System.Int64)"/>
            </summary>
            <param name="action"></param>
            <param name="timeTilEnqueueInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.ScheduleOnInterval(System.Action,System.Int64,System.Int64)">
            <summary>
            <see cref="M:Retlang.Core.IScheduler.ScheduleOnInterval(System.Action,System.Int64,System.Int64)"/>
            </summary>
            <param name="action"></param>
            <param name="firstInMs"></param>
            <param name="regularInMs"></param>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.Start">
            <summary>
            <see cref="M:Retlang.Fibers.IFiber.Start"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.Join">
            <summary>
            <see cref="M:Retlang.Fibers.IThreadFiber.Join"/>
            </summary>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiber.Dispose">
            <summary>
            Stops the thread.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.ThreadFiber.Thread">
            <summary>
            <see cref="T:Retlang.Fibers.IFiber"/>
            </summary>
        </member>
        <member name="P:Retlang.Fibers.ThreadFiber.DisposableCount">
            <summary>
            Number of disposables.
            </summary>
        </member>
        <member name="T:Retlang.Fibers.ExecutionState">
            <summary>
             Fiber execution state management
            </summary>
        </member>
        <member name="F:Retlang.Fibers.ExecutionState.Created">
            <summary>
             Created but not running
            </summary>
        </member>
        <member name="F:Retlang.Fibers.ExecutionState.Running">
            <summary>
             After start
            </summary>
        </member>
        <member name="F:Retlang.Fibers.ExecutionState.Stopped">
            <summary>
             After stopped
            </summary>
        </member>
        <member name="T:Retlang.Channels.RequestReplyChannel`2">
            <summary>
            Channel for synchronous and asynchronous requests.
            </summary>
            <typeparam name="R"></typeparam>
            <typeparam name="M"></typeparam>
        </member>
        <member name="T:Retlang.Channels.IRequestReplyChannel`2">
            <summary>
            Typed channel for request/reply
            </summary>
            <typeparam name="R"></typeparam>
            <typeparam name="M"></typeparam>
        </member>
        <member name="T:Retlang.Channels.IRequestPublisher`2">
            <summary>
            
            </summary>
            <typeparam name="R"></typeparam>
            <typeparam name="M"></typeparam>
        </member>
        <member name="M:Retlang.Channels.IRequestPublisher`2.SendRequest(`0)">
            <summary>
            Send request on the channel.
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.Channels.IReplySubscriber`2">
            <summary>
            Methods for working with a replyChannel
            </summary>
            <typeparam name="R"></typeparam>
            <typeparam name="M"></typeparam>
        </member>
        <member name="M:Retlang.Channels.IReplySubscriber`2.Subscribe(Retlang.Core.IDisposingExecutor,System.Action{Retlang.Channels.IRequest{`0,`1}})">
            <summary>
            Subscribe to a request on the channel.
            </summary>
            <param name="responder"></param>
            <param name="onRequest"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.RequestReplyChannel`2.Subscribe(Retlang.Core.IDisposingExecutor,System.Action{Retlang.Channels.IRequest{`0,`1}})">
            <summary>
            Subscribe to requests.
            </summary>
            <param name="responder"></param>
            <param name="onRequest"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.RequestReplyChannel`2.SendRequest(`0)">
            <summary>
            Send request to any and all subscribers.
            </summary>
            <param name="p"></param>
            <returns>null if no subscribers registered for request.</returns>
        </member>
        <member name="T:Retlang.Core.SynchronousActionQueue">
            <summary>
            A synchronous queue typically used for testing.
            </summary>
        </member>
        <member name="M:Retlang.Core.SynchronousActionQueue.EnqueueAll(System.Action[])">
            <summary>
            <see cref="M:Retlang.Core.IDisposingExecutor.Enqueue(System.Action)"/>
            </summary>
            <param name="actions"></param>
        </member>
        <member name="M:Retlang.Core.SynchronousActionQueue.Enqueue(System.Action)">
            <summary>
            Queue action
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Retlang.Core.SynchronousActionQueue.Add(System.IDisposable)">
            <summary>
            Add Disposable.
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:Retlang.Core.SynchronousActionQueue.Remove(System.IDisposable)">
            <summary>
            Remove Disposable.
            </summary>
            <param name="victim"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Core.SynchronousActionQueue.Run">
            <summary>
            Start Consuming events.
            </summary>
        </member>
        <member name="M:Retlang.Core.SynchronousActionQueue.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="P:Retlang.Core.SynchronousActionQueue.DisposableCount">
            <summary>
            Count of Disposables.
            </summary>
        </member>
        <member name="T:Retlang.Core.BatchAndSingleExecutor">
            <summary>
            Default Action executor.
            </summary>
        </member>
        <member name="T:Retlang.Core.IBatchAndSingleExecutor">
            <summary>
             Executes pending action(s).
            </summary>
        </member>
        <member name="M:Retlang.Core.IBatchAndSingleExecutor.Execute(System.Action)">
            <summary>
             Execute a single pending action.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Retlang.Core.BatchAndSingleExecutor.ExecuteAll(System.Action[])">
            <summary>
            <see cref="M:Retlang.Core.IBatchExecutor.ExecuteAll(System.Action[])"/>
            </summary>
        </member>
        <member name="M:Retlang.Core.BatchAndSingleExecutor.Execute(System.Action)">
            <summary>
            Execute single action
            </summary>
        </member>
        <member name="P:Retlang.Core.BatchAndSingleExecutor.IsEnabled">
            <summary>
            When disabled, actions will be ignored by executor. The executor is typically disabled at shutdown
            to prevent any pending actions from being executed. 
            </summary>
        </member>
        <member name="T:Retlang.Fibers.SynchronousFiber">
            <summary>
            Synchronous Fiber does not use a backing thread or a thread pool for execution. Events are added to pending
            lists for execution. These events can be executed synchronously by a calling thread. This class
            is not thread safe and probably should not be used in production code. 
            
            The class is typically used for unit testing asynchronous code to make it completely synchronous and
            deterministic.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.Start">
            <summary>
            No Op
            </summary>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.Dispose">
            <summary>
            Invokes Disposables.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.EnqueueAll(System.Action[])">
            <summary>
            Adds all events to pending list.
            </summary>
            <param name="actions"></param>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.Enqueue(System.Action)">
            <summary>
            Add event to pending list.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.Add(System.IDisposable)">
            <summary>
            add to disposable list.
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.Remove(System.IDisposable)">
            <summary>
            Remove Disposable.
            </summary>
            <param name="disposable"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.Schedule(System.Action,System.Int64)">
            <summary>
            Adds a scheduled event to the list. 
            </summary>
            <param name="action"></param>
            <param name="timeTilEnqueueInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.ScheduleOnInterval(System.Action,System.Int64,System.Int64)">
            <summary>
            Adds scheduled event to list.
            </summary>
            <param name="action"></param>
            <param name="firstInMs"></param>
            <param name="regularInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.ExecuteAllPending">
            <summary>
            Execute all actions in the pending list.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.SynchronousFiber.ExecuteAllScheduled">
            <summary>
            execute all scheduled.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.SynchronousFiber.DisposableCount">
            <summary>
            Count of Disposables.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.SynchronousFiber.Disposables">
            <summary>
            All Disposables.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.SynchronousFiber.Pending">
            <summary>
            All Pending actions.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.SynchronousFiber.Scheduled">
            <summary>
            All Scheduled events.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.SynchronousFiber.ExecutePendingImmediately">
            <summary>
            If true events will be executed immediately rather than added to a pending list.
            </summary>
        </member>
        <member name="T:Retlang.Core.ActionExecutor">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:Retlang.Core.ActionExecutor.EnqueueAll(System.Action[])">
            <summary>
            <see cref="M:Retlang.Core.IDisposingExecutor.EnqueueAll(System.Action[])"/>
            </summary>
            <param name="actions"></param>
        </member>
        <member name="M:Retlang.Core.ActionExecutor.Enqueue(System.Action)">
            <summary>
            Queue action.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Retlang.Core.ActionExecutor.Add(System.IDisposable)">
            <summary>
            Add disposable.
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:Retlang.Core.ActionExecutor.Remove(System.IDisposable)">
            <summary>
            Remove
            </summary>
            <param name="victim"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Core.ActionExecutor.DequeueAll">
            <summary>
            Remove all actions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.Core.ActionExecutor.ExecuteNextBatch">
            <summary>
            Remove all actions and execute.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Retlang.Core.ActionExecutor.Run">
            <summary>
            Execute actions until stopped.
            </summary>
        </member>
        <member name="M:Retlang.Core.ActionExecutor.Stop">
            <summary>
            Stop consuming events.
            </summary>
        </member>
        <member name="P:Retlang.Core.ActionExecutor.BatchExecutor">
            <summary>
            Executor for events.
            </summary>
        </member>
        <member name="P:Retlang.Core.ActionExecutor.MaxDepth">
            <summary>
            Max number of events to be queued.
            </summary>
        </member>
        <member name="P:Retlang.Core.ActionExecutor.MaxEnqueueWaitTime">
            <summary>
            Max time to wait for space in the queue.
            </summary>
        </member>
        <member name="P:Retlang.Core.ActionExecutor.DisposableCount">
            <summary>
            Disposable Count.
            </summary>
        </member>
        <member name="T:Retlang.Core.IPendingEvent">
            <summary>
            A scheduled event.
            </summary>
        </member>
        <member name="M:Retlang.Core.IPendingEvent.Execute(System.Int64)">
            <summary>
            Execute this event and optionally schedule another execution.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Retlang.Core.IPendingEvent.Expiration">
            <summary>
            Time of expiration for this event
            </summary>
        </member>
        <member name="T:Retlang.Channels.Filter`1">
            <summary>
            Message filter delegate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.Channels.ChannelSubscription`1">
            <summary>
            Subscription for events on a channel.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.ChannelSubscription`1.#ctor(Retlang.Core.IDisposingExecutor,System.Action{`0})">
            <summary>
            Construct the subscription
            </summary>
            <param name="queue"></param>
            <param name="receiveMethod"></param>
        </member>
        <member name="M:Retlang.Channels.ChannelSubscription`1.OnMessageOnProducerThread(`0)">
            <summary>
            Receives the event and queues the execution on the target queue.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Retlang.Fibers.IThreadFiberFactory">
            <summary>
            Factory for creating backing threads.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.IThreadFiberFactory.CreateThreadFiber(Retlang.Core.IBatchExecutor)">
            <summary>
            Create ThreadFiber with IBatchExecutor
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.IThreadFiberFactory.CreateThreadFiber(Retlang.Core.IBatchExecutor,System.String)">
            <summary>
            Create named fiber thread.
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.Core.IThreadController">
            <summary>
            Controls thread lifecycle.
            </summary>
        </member>
        <member name="M:Retlang.Core.IThreadController.Start">
            <summary>
            Starts thread execution.
            </summary>
        </member>
        <member name="M:Retlang.Core.IThreadController.Stop">
            <summary>
            Stops thread
            </summary>
        </member>
        <member name="M:Retlang.Core.IThreadController.Join">
            <summary>
            Waits for thread to finish.
            </summary>
        </member>
        <member name="T:Retlang.Core.DisposableList">
            <summary>
            Registry for disposables. Provides thread safe methods for list of disposables.
            </summary>
        </member>
        <member name="M:Retlang.Core.DisposableList.Add(System.IDisposable)">
            <summary>
            Add Disposable
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:Retlang.Core.DisposableList.Remove(System.IDisposable)">
            <summary>
            Remove Disposable.
            </summary>
            <param name="victim"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Core.DisposableList.Dispose">
            <summary>
            Disposes all disposables registered in list.
            </summary>
        </member>
        <member name="P:Retlang.Core.DisposableList.Count">
            <summary>
            Number of registered disposables.
            </summary>
        </member>
        <member name="T:Retlang.Core.IThreadPool">
            <summary>
            A thread pool for executing asynchronous events.
            </summary>
        </member>
        <member name="M:Retlang.Core.IThreadPool.Queue(System.Threading.WaitCallback)">
            <summary>
            Queue event for execution.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="T:Retlang.Core.DefaultThreadPool">
            <summary>
            Default implementation that uses the .NET thread pool.
            </summary>
        </member>
        <member name="M:Retlang.Core.DefaultThreadPool.Queue(System.Threading.WaitCallback)">
            <summary>
            Queue event.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="T:Retlang.Channels.QueueChannel`1">
            <summary>
            Default QueueChannel implementation. Once and only once delivery to first available consumer.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.QueueChannel`1.Subscribe(Retlang.Core.IDisposingExecutor,System.Action{`0})">
            <summary>
            Subscribe to executor messages. 
            </summary>
            <param name="executor"></param>
            <param name="onMessage"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.QueueChannel`1.Publish(`0)">
            <summary>
            Publish message onto queue. Notify consumers of message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Retlang.Channels.Channel`1">
            <summary>
             Default Channel Implementation. Methods are thread safe.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Retlang.Channels.Channel`1.Subscribe(Retlang.Core.IDisposingExecutor,System.Action{`0})">
            <summary>
            <see cref="M:Retlang.Channels.ISubscriber`1.Subscribe(Retlang.Core.IDisposingExecutor,System.Action{`0})"/>
            </summary>
            <param name="executor"></param>
            <param name="receive"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.Channel`1.Publish(`0)">
            <summary>
            <see cref="M:Retlang.Channels.IPublisher`1.Publish(`0)"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.Channel`1.ClearSubscribers">
            <summary>
            Remove all subscribers.
            </summary>
        </member>
        <member name="M:Retlang.Channels.Channel`1.SubscribeToBatch(Retlang.Core.IScheduler,System.Action{System.Collections.Generic.IList{`0}},System.Int32)">
            <summary>
            <see cref="M:Retlang.Channels.ISubscriber`1.SubscribeToBatch(Retlang.Core.IScheduler,System.Action{System.Collections.Generic.IList{`0}},System.Int32)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.Channel`1.SubscribeToKeyedBatch``1(Retlang.Core.IScheduler,System.Converter{`0,``0},System.Action{System.Collections.Generic.IDictionary{``0,`0}},System.Int32)">
            <summary>
            <see cref="M:Retlang.Channels.ISubscriber`1.SubscribeToKeyedBatch``1(Retlang.Core.IScheduler,System.Converter{`0,``0},System.Action{System.Collections.Generic.IDictionary{``0,`0}},System.Int32)"/>
            </summary>
            <typeparam name="K"></typeparam>
            <param name="scheduler"></param>
            <param name="keyResolver"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.Channel`1.SubscribeOnProducerThreads(Retlang.Channels.IProducerThreadSubscriber{`0})">
            <summary>
            Subscribes to events on producer threads. Subscriber could be called from multiple threads.
            </summary>
            <param name="subscriber"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.Channel`1.SubscribeOnProducerThreads(System.Action{`0})">
            <summary>
            Subscribes an action to be executed for every event posted to the channel. Action should be thread safe. 
            Action may be invoked on multiple threads.
            </summary>
            <param name="subscriber"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Channels.Channel`1.SubscribeToLast(Retlang.Core.IScheduler,System.Action{`0},System.Int32)">
            <summary>
            Subscription that delivers the latest message to the consuming thread.  If a newer message arrives before the consuming thread
            has a chance to process the message, the pending message is replaced by the newer message. The old message is discarded.
            </summary>
            <param name="scheduler"></param>
            <param name="receive"></param>
            <param name="intervalInMs"></param>
            <returns></returns>
        </member>
        <member name="T:Retlang.Fibers.ScheduledEvent">
            <summary>
            Event scheduled to be executed.
            </summary>
        </member>
        <member name="M:Retlang.Fibers.ScheduledEvent.#ctor(System.Action,System.Int64)">
            <summary>
            Schedule an event for a single execution
            </summary>
            <param name="runnable"></param>
            <param name="time"></param>
        </member>
        <member name="M:Retlang.Fibers.ScheduledEvent.#ctor(System.Action,System.Int64,System.Int64)">
            <summary>
            Schedule Recurring Event.
            </summary>
            <param name="action"></param>
            <param name="firstIntervalInMs"></param>
            <param name="regularIntervalInMs"></param>
        </member>
        <member name="M:Retlang.Fibers.ScheduledEvent.Equals(System.Object)">
            <summary>
            Equality operation typically used for testing.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.ScheduledEvent.GetHashCode">
            <summary>
            Hash
            </summary>
            <returns></returns>
        </member>
        <member name="P:Retlang.Fibers.ScheduledEvent.Action">
            <summary>
            The Action to be executed.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.ScheduledEvent.FirstIntervalInMs">
            <summary>
            The first time the event will be executed.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.ScheduledEvent.RegularIntervalInMs">
            <summary>
            Regular interval in ms for action.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.ScheduledEvent.IsRecurring">
            <summary>
            Determine if event will be fired on regular interval.
            </summary>
        </member>
        <member name="T:Retlang.Fibers.ThreadFiberFactory">
            <summary>
            Default implementation for IThreadFiberFactory
            </summary>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiberFactory.CreateThreadFiber(Retlang.Core.IBatchExecutor)">
            <summary>
            <see cref="M:Retlang.Fibers.IThreadFiberFactory.CreateThreadFiber(Retlang.Core.IBatchExecutor)"/>
            </summary>
            <param name="executor"></param>
            <returns></returns>
        </member>
        <member name="M:Retlang.Fibers.ThreadFiberFactory.CreateThreadFiber(Retlang.Core.IBatchExecutor,System.String)">
            <summary>
            <see cref="M:Retlang.Fibers.IThreadFiberFactory.CreateThreadFiber(Retlang.Core.IBatchExecutor,System.String)"/>
            </summary>
            <param name="executor"></param>
            <param name="threadName"></param>
            <returns></returns>
        </member>
        <member name="P:Retlang.Fibers.ThreadFiberFactory.MaxQueueDepth">
            <summary>
            Maximum depth for queue.
            </summary>
        </member>
        <member name="P:Retlang.Fibers.ThreadFiberFactory.MaxEnqueueWaitTime">
            <summary>
            Max time to wait for queue to clear.
            </summary>
        </member>
    </members>
</doc>
