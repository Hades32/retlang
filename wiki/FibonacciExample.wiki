The following example demonstrates how to calculate a [http://en.wikipedia.org/wiki/Fibonacci_number Fibonnaci sequence] using Retlang. 

Example provided by [OliverGugenheim], ported to Channel API by JordanSamuels.  Latest code should be at [http://retlang.googlecode.com/svn/trunk/src/RetlangTests/Examples/FibonacciDemonstration.cs here].  For another mathematical example, see AlgebraDemonstration.


{{{
using System;
using NUnit.Framework;
using Retlang.Channels;
using Retlang.Core;
using Retlang.Fibers;

namespace RetlangTests.Examples
{
    
    [TestFixture]
    [Category("Demo")]
    [Ignore("Demo")]
    public class FibonacciDemonstration
    {
        // Simple immutable class that serves as a message
        // to be passed between services.
        class IntPair
        {
            private readonly int _first;
            private readonly int _second;

            public IntPair(int first, int second)
            {
                _first = first;
                _second = second;
            }

            public int First
            {
                get { return _first; }
            }

            public int Second
            {
                get { return _second; }
            }
        }

        // This class calculates the next value in a Fibonacci sequence.
        // It listens for the previous pair on one topic, and then publishes
        // a new pair with the latest value onto the reply topic.
        // When a specified limit is reached, it stops processing.
        class FibonacciCalculator
        {
            private readonly IThreadFiber _threadFiber;
            private readonly string _name;
            private readonly ISubscriber<IntPair> _inboundChannel;
            private readonly IChannel<IntPair> _outboundChannel;
            private readonly int _limit;

            public FibonacciCalculator(IThreadFiber fiber, string name, 
                ISubscriber<IntPair> inboundChannel, 
                IChannel<IntPair> outboundChannel,
                int limit)
            {
                _threadFiber = fiber;
                _name = name;
                _inboundChannel = inboundChannel;
                _outboundChannel = outboundChannel;
                _inboundChannel.Subscribe(fiber, CalculateNext);

                
                _limit = limit;
            }

            public void Begin(IntPair pair)
            {
                Console.WriteLine(_name + " " + pair.Second);
                _outboundChannel.Publish(pair);
            }

            private void CalculateNext(IntPair receivedPair)
            {
                int next = receivedPair.First + receivedPair.Second;

                IntPair pairToPublish = new IntPair(receivedPair.Second, next);
                _outboundChannel.Publish(pairToPublish);
                
                if (next > _limit)
                {
                    Console.WriteLine("Stopping " + _name);
                    _threadFiber.Dispose();
                    
                    return;
                }
                Console.WriteLine(_name + " " + next);
            }
        }

        [Test]
        public void DoDemonstration()
        {
            ThreadFiberFactory factory = new ThreadFiberFactory();
            BatchExecutor executor = new BatchExecutor();

            using (DisposableList disposables = new DisposableList())
            {
                // Two instances of the calculator are created.  One is named "Odd" 
                // (it calculates the 1st, 3rd, 5th... values in the sequence) the
                // other is named "Even".  They message each other back and forth
                // with the latest two values and successively build the sequence.
                int limit = 1000;

                // Two channels for communication.  Naming convention is inbound.
                IChannel<IntPair> oddChannel = new Channel<IntPair>();
                IChannel<IntPair> evenChannel = new Channel<IntPair>();
                
                IThreadFiber oddFiber = factory.CreateThreadFiber(executor);
                disposables.Add(oddFiber);
                oddFiber.Start();

                
                FibonacciCalculator oddCalculator = new FibonacciCalculator(oddFiber, "Odd", oddChannel, evenChannel, limit);

                IThreadFiber evenFiber = factory.CreateThreadFiber(executor);
                disposables.Add(evenFiber); 
                evenFiber.Start();

                FibonacciCalculator evenCalculator = new FibonacciCalculator(evenFiber, "Even", evenChannel, oddChannel, limit);

                oddCalculator.Begin(new IntPair(0, 1));

                oddFiber.Join();
                evenFiber.Join();
            }
            
        }
    }
}

}}} 
 