Example by OliverGugenheim.

The purpose of this simple example is to show how an application can keep a mutable object safe while collecting data from multiple threads without locking.  The example creates three sources that each publishes a sequence of numbers to a topic and a sink that listens to the topic and adds up all the numbers received.  Once all the sources are exhausted, the threads are all shut down.  Notice that while three threads are publishing numbers the correct total is calculated without using any locking.

{{{
    [TestFixture]
    public class Demonstration
    {
        // This class is a producer or source.  It is given a topic on
        // construction and will publish a sequence of ints starting 
        // at one and continuing to the specified limit to that topic.
        private class NumberSource
        {
            // The process (thread) that will run the code.
            private readonly IProcessContext _processContext;
            // The topic we wish to publish to.
            private readonly object _topic;
            // The highest number this number source will publish.
            private readonly int _limit;

            public NumberSource(IProcessContext processContext, object topic, int limit)
            {
                _processContext = processContext;
                _limit = limit;
                _topic = topic;
                // To subscribe to a particular topic we provide a mechanism to 
                // match the topic as well as a delegate to be invoked when 
                // a message to be delivered.
                ITopicMatcher matcher = new TopicEquals(_topic);
                _processContext.Subscribe<string>(matcher, SubscribeToStart);
            }

            // The signature of the delegate for the Subscribe method requires
            // a message header and the type of the message being listened for.
            private void SubscribeToStart(IMessageHeader header, string message)
            {
                if( message.Equals("Start"))
                {
                    Console.WriteLine("Starting source " + _limit);
                    SendNumbers();
                }
            }

            // This method will send the numbers 1 to _limit to the topic and then the string "done"
            private void SendNumbers()
            {
                for (int idx = 1; idx <= _limit; idx++)
                {
                    _processContext.Publish(_topic, idx);
                    // Occasionally a number in the sequence is published to show interleaving.
                    if (idx % 10 == 0)
                    {
                        Console.WriteLine("Source " + _limit + " publishing " + idx);
                    }
                }
                _processContext.Publish(_topic, "Done with source for " + _limit);
            }
        }

        // This class is a consumer or sink.  It listens for ints to be
        // published on a specified topic and adds them to its internal sum.
        private class SummationSink
        {
            // The process (thread) that will listen for messages.
            private readonly IProcessContext _processContext;
            private readonly AutoResetEvent _completionEvent;
            private readonly int _expectedNumberSources;
            private int _sum = 0;
            private int _sourcesSignaledDone;
            private readonly object _topic;

            public SummationSink(IProcessContext processContext, object topic, AutoResetEvent completionEvent,
                                 int expectedNumberSources)
            {
                _processContext = processContext;
                _completionEvent = completionEvent;
                _expectedNumberSources = expectedNumberSources;
                ITopicMatcher topicSelector = new TopicEquals(topic);
                _processContext.Subscribe<int>(topicSelector, Add);
                _processContext.Subscribe<string>(topicSelector, ListenForDone);
                _topic = topic;
            }

            // Our summation method must implement this signature 
            // as it functions as a delegate.  The header is 
            // ignored in this simple example.
            private void Add(IMessageHeader header, int amount)
            {
                _sum += amount;
            }

            public void SendStartSignal()
            {
                _processContext.Publish(_topic, "Start");
            }

            // This method will determine when a source is done sending more numbers.
            private void ListenForDone(IMessageHeader header, string message)
            {
                if( message.StartsWith("Done"))
                {
                    Console.WriteLine(message);
                     _sourcesSignaledDone += 1;
                }
                if(_sourcesSignaledDone == _expectedNumberSources)
                {
                    Console.WriteLine("All sources exhausted.");
                    _completionEvent.Set();
                }    
            }

            public int Sum
            {
                get { return _sum; }
            }
        }

        [Test]
        public void TestSummation()
        {
            // A factory that will create some threads.
            ProcessContextFactory processContextFactory = new ProcessContextFactory();
            processContextFactory.Start();

            // We create three sources, each running on its own thread
            // all publishing to the same topic.  We variously publish
            // the numbers 1-100, 1-50 and 1-200.
            IProcessContext processContextOne = processContextFactory.Create();
            new NumberSource(processContextOne, "Summation Channel", 200);

            IProcessContext processContextTwo = processContextFactory.Create();
            new NumberSource(processContextTwo, "Summation Channel", 50);

            IProcessContext processContextThree = processContextFactory.Create();
            new NumberSource(processContextThree, "Summation Channel", 100);

            // We create one sink to listen to all the publishing threads.
            IProcessContext processContextFour = processContextFactory.Create();
            int numberSources = 3;
            AutoResetEvent completionEvent = new AutoResetEvent(false);
            SummationSink summationSink = new SummationSink(processContextFour, "Summation Channel", completionEvent, numberSources);

            // Start all the threads.
            processContextOne.Start();
            processContextTwo.Start();
            processContextThree.Start();
            processContextFour.Start();

            // send all the sequences from each source
            summationSink.SendStartSignal();

            // Pause to allow all the threads to complete.
            completionEvent.WaitOne(10000, false);

            Console.WriteLine("The total sum is " + summationSink.Sum);

            // And assert that the total is correct.
            Assert.AreEqual(26425, summationSink.Sum);

            // Notice that despite having three threads all contending to
            // send messages to one place, our code has no locks and still
            // preserves a single mutable total correctly.

            // some clean up is nice for tidiness
            processContextOne.Stop();
            processContextOne.Join();
            processContextTwo.Stop();
            processContextTwo.Join();
            processContextThree.Stop();
            processContextThree.Join();
            processContextFour.Stop();
            processContextFour.Join();
            processContextFactory.Stop();
            processContextFactory.Join();
        }
    }
}}}