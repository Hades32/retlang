#labels Featured
The purpose of Retlang is to facilitate building multi-threaded applications that replace direct method calls with asynchronous messages.  Everyone who has worked on multi-threaded code is aware of how difficult it is.  The twin problems of liveness and correctness haunt every decision:  Must I add a lock here?  Will the addition of that lock create a potential for deadlock?  Are the locks being taken in the correct order in every code path?  Even if the application functions properly, extension is difficult, since adding a new path can create problems for a previously correctly functioning system of locking.

Using Retlang, you never have to use 

{{{
Thread thread = new Thread();
thread.Start();
}}}

or

{{{
object lockObject = new object();

lock ( lockObject ) {
	// work with some shared mutable object ...
}
}}}

Using the pub/sub paradigm, Retlang can be used to build highly concurrent applications based upon the [http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html Pipes and Filters] design pattern. With this design, a Retlang IFiber is created per filter. The Retlang channels provide the pipe between filters. 

This is accomplished by dividing your application into pieces that function independently (each on its own thread) and that communicate only by publishing and subscribing to messages.  The Retlang library will assure that the messages are delivered to each subscriber serially and in order.  The primary interface for application developers is the {{{IFiber}}}.  You can think of an {{{IFiber}}} as a thread.  

A basic application that listened on a socket for some information, did some business logic on the data received, and displayed the results in a GUI might be designed with three fibers.  One fiber would subscribe to the socket and publish information as it was received.  A second would subscribe to what the socket listener published, perform the business logic, and then publish the results.  The final fiber would listen for the business logic messages, and update the GUI. All the Retlang interfaces are mockable, so you should be able to test each portion of your application completely and independently.

Continue learning about Retlang by taking a look at the ThreadingDesign. A basic understanding on how events are created and received is essential to understanding how to design applications using the framework.


=== Some Examples ===

[http://code.google.com/p/retlang/source/browse/trunk/src/RetlangTests/Examples/BasicExamples.cs Basic Examples]

FibonacciExample - A basic example for calculating a fibonacci sequence.

AlgebraDemonstration

SummationExample


 
 
 
 