#labels Featured
The purpose of Retlang is to facilitate building multi-threaded applications that replace direct method calls with asynchronous messages.  Everyone who has worked on multi-threaded code is aware of how difficult it is.  The twin problems of liveness and correctness haunt every decision:  Must I add a lock here?  Will the addition of that lock create a potential for deadlock?  Are the locks being taken in the correct order in every code path?  Even if the application functions properly, extension is difficult, since adding a new path can create problems for a previously correctly functioning system of locking.

Using Retlang, you never have to use 

{{{
Thread thread = new Thread();
thread.Start();
}}}

or

{{{
object lockObject = new object();

lock ( lockObject ) {
	// work with some shared mutable object ...
}
}}}

Using the pub/sub paradigm, Retlang can be used to build highly concurrent applications based upon the [http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html Pipes and Filters] design pattern. With this design, a Retlang IProcessBus (or IProcessContext) is created per filter. The Retlang message bus provides the pipe between filters. 

This is accomplished by dividing your application into pieces that function independently (each on its own thread) and that communicate only by publishing and subscribing to messages.  The Retlang library will assure that the messages are delivered to each subscriber serially and in order.  The primary interface for application developers is the {{{IProcessBus}}}.  You can think of an {{{IProcessBus}}} as a thread. (In fact, one implementation of {{{IProcessBus}}}, the {{{ProcessContext}}}, each has its own backing thread.)  The most important methods for application developers on this interface are {{{Publish}}} and the various {{{Subscribe}}} methods.  To publish a message, your code simply calls the {{{Publish}}} method.  To subscribe to a message you indicate a topic (some key that determines what messages interest you) and a delegate to be executed when a message is received.  As long as two {{{IProcessBus}}}es were created from the same {{{ProcessContextFactory}}}, messages can be delivered between them.

A basic application that listened on a socket for some information, did some business logic on the data received, and displayed the results in a GUI might be designed with three {{{ProcessContext}}}s (threads).  One {{{ProcessContext}}} would subscribe to the socket and publish information as it was received.  A second would subscribe to what the socket listener published, perform the business logic, and then publish the results.  The final {{{ProcessContext}}} would listen for the business logic messages, and update the GUI.  The messages can take the form of XML strings, binary serializations of objects, or immutable (and therefore thread safe) data classes.  The three {{{ProcessContext}}}s would all be created from the same {{{ProcessContextFactory}}} and perhaps instantiated using some dependency injection framework.  All the Retlang interfaces are mockable, so you should be able to test each portion of your application completely and independently.

Continue learning about Retlang by taking a look at the ThreadingDesign. A basic understanding on how events are created and received is essential to understanding how to design applications using the framework.


=== Some Examples ===

[http://code.google.com/p/retlang/source/browse/trunk/src/RetlangTests/Examples/BasicExamples.cs Basic Examples]

FibonacciExample - A basic example for calculating a fibonacci sequence.

AlgebraDemonstration

MultiplicationExample - A slightly more advanced example that uses unique topics and asynchronous replies to multiply numbers.

SummationExample


 
 
 
 